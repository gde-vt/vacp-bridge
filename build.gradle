apply plugin: 'base'
apply plugin: 'application'

mainClassName = "id.co.veritrans.app.Main"

ext.validEnvironments = ['development', 'staging', 'production']
ext.env = hasProperty('env') ? env : 'development'

if (env in validEnvironments) {
    println("executing for env: " + env)
} else {
    throw new GradleException("unknown env: ${env}, validEnvironments: ${validEnvironments}")
}

allprojects {
    version = '1.0.0-SNAPSHOT'

    ext.env = env
    ext.libSlf4jVersion = '1.7.10'
    ext.libLogbackVersion = '1.1.2'
    ext.libJunitVersion = '4.11'
    ext.libSpringFrameworkVersion = '4.1.4.RELEASE'
    ext.libJacksonVersion = '2.5.0'
    ext.libJavaxValidationVersion = '1.1.0.Final'
    ext.libHibernateValidatorVersion = '5.1.3.Final'
    ext.libAspectjVersion = '1.8.4'
}

subprojects {
    apply from: rootProject.file('build.common.gradle')
}

repositories {
    mavenCentral()
}

dependencies {
    compile project(':restful-server')
}

jar {
    manifest.attributes provider: 'gradle'
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.2.1'
    distributionUrl = 'http://services.gradle.org/distributions/gradle-2.2.1-all.zip'
}

task mergedJavadoc(type: Javadoc, description: 'Creates Javadoc from all the projects.') {
    title = 'All modules'
    destinationDir = new File(project.buildDir, 'merged-javadoc')

    // Note: The closures below are executed lazily.
    source {
        subprojects*.sourceSets*.main*.allSource
    }
    classpath.from {
        subprojects*.configurations*.compile*.copyRecursive({ !(it instanceof ProjectDependency); })*.resolve()
    }
}
